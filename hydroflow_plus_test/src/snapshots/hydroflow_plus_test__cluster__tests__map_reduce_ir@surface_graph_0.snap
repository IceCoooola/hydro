---
source: hydroflow_plus_test/src/cluster.rs
expression: ir.surface_syntax_string()
---
1v1 = source_iter ({ use crate :: __staged :: cluster :: * ; vec ! ["abc" , "abc" , "xyz" , "abc"] });
2v1 = map ({ use crate :: __staged :: cluster :: * ; | s | s . to_string () });
3v1 = enumerate ();
4v1 = map ({ use crate :: __staged :: cluster :: * ; let all_ids_vec = { use hydroflow_plus_cli_integration :: __staged :: runtime :: * ; let cli = FAKE ; let self_id = 1usize ; cli . meta . clusters . get (& self_id) . unwrap () } ; | (i , w) | ((i % all_ids_vec . len ()) as u32 , w) });
5v1 = map (| (id , data) | { (id , hydroflow_plus :: runtime_support :: bincode :: serialize :: < std :: string :: String > (& data) . unwrap () . into ()) });
6v1 = dest_sink ({ use hydroflow_plus_cli_integration :: __staged :: runtime :: * ; let port = "port_0" ; let self_cli = FAKE ; { self_cli . port (port) . connect_local_blocking :: < ConnectedDemux < ConnectedDirect > > () . into_sink () } });
7v1 = source_stream ({ use hydroflow_plus_cli_integration :: __staged :: runtime :: * ; let port = "port_1" ; let self_cli = FAKE ; { self_cli . port (port) . connect_local_blocking :: < ConnectedTagged < ConnectedDirect > > () . into_source () } });
8v1 = map (| res | { let (id , b) = res . unwrap () ; (id , hydroflow_plus :: runtime_support :: bincode :: deserialize :: < (std :: string :: String , i32) > (& b) . unwrap ()) });
9v1 = map ({ use hydroflow_plus :: __staged :: stream :: * ; | (_ , b) | b });
10v1 = reduce_keyed :: < 'static > ({ use crate :: __staged :: cluster :: * ; | total , count | * total += count });
11v1 = for_each ({ use crate :: __staged :: cluster :: * ; | (string , count) | println ! ("{}: {}" , string , count) });

1v1 -> 2v1;
2v1 -> 3v1;
3v1 -> 4v1;
5v1 -> 6v1;
4v1 -> 5v1;
7v1 -> 8v1;
8v1 -> 9v1;
9v1 -> 10v1;
10v1 -> 11v1;
